CREATE OR REPLACE DISTRIBUTED QUERY match_application_entities(
  FLOAT Application_Full_Name_weight = 0.2,
  FLOAT Application_DOB_weight = 0.2,
  FLOAT Application_Email_weight = 0.2,
  FLOAT Application_Phone_weight = 0.2,
  FLOAT Application_Address_weight = 0.2,
  FLOAT Application_IP_weight = 0.2,
  FLOAT Application_ID_weight = 1.0,
  FLOAT Application_Device_weight = 1.0,
  FLOAT Application_Party_weight = 1.0,
  FLOAT Application_Account_weight = 1.0,
  FLOAT Application_Card_weight = 1.0,
  INT num_of_source_batches = 10, // number of source batches
  INT num_of_target_batches = 1, // number of target batches
  FLOAT threshold = 1.0, // if a total matching score between two entities exceed the threshold, a similarity edge will be created between the matching entities
  INT pii_low_connections_limit = 100, // maximum out degree of an attribute. The case will be skipped if the same attribute is connected to too many entities
  INT pii_high_connections_limit = 25000, // maximum out degree of an attribute. The case will be skipped if the same attribute is connected to too many entities
  DATETIME compute_entities_after_date = to_datetime("1970-01-01 00:00:00") // All entities that were created in TG after this date, will be computed to find similarity edges related to these new entities. The default value is the earliest time possible (great for the first time running this query)
) {

  ListAccum<VERTEX<Application>> @entity_list;
  MapAccum<VERTEX<Application>,FLOAT> @entity_map;
  SumAccum<INT> @@count;
  MaxAccum<FLOAT> @@max;
  MinAccum<FLOAT> @@min;
  AvgAccum @@avg;
  SetAccum<STRING> @@edge_type_set;
  OrAccum @is_candidate;

  /* PII connections that are used in this ER solution */
  @@edge_type_set = (
    "Application_Has_Full_Name",
    "Application_Has_DOB",
    "Application_Has_Email",
    "Application_Has_Phone",
    "Application_Has_Address",
    "Application_Has_IP",
    "Application_Has_ID",
    "Application_Has_Device",
    "Application_Has_Party",
    "Application_Has_Account",
    "Application_Has_Card"
  );

  DATETIME start_time = now();
  log(true, "UDF:: match_entities start time: " + datetime_format(start_time));

  all_entities = {Application.*};

  /* Batching source entities */
  
  FOREACH i IN RANGE[0, num_of_source_batches-1] DO

      /* Prepare the source batched entitities */
  
      batched_entities = SELECT s
          FROM all_entities:s
          WHERE getvid(s)%num_of_source_batches == i AND s.created_at > compute_entities_after_date
      ;
  
      batched_entities = SELECT s
          FROM batched_entities:s-(@@edge_type_set:e)->:t
          WHERE t.outdegree() > 1 AND t.outdegree() < pii_low_connections_limit
      ;
  
      /* Prepare the low-degree PIIs that are connected to the source batched entitities */
  
      low_degree_piis = SELECT t
          FROM batched_entities:s-(@@edge_type_set:e)->:t
          WHERE t.outdegree() > 1 AND t.outdegree() < pii_low_connections_limit
      ;
  
      /* For each high-degree PII that is connected to the relevant source batched entities,
      save a list of all source batched entities on that PII */

      piis = SELECT t
          FROM batched_entities:s-(@@edge_type_set:e)->:t
          WHERE t.outdegree(@@edge_type_set) > 1 AND t.outdegree() < pii_high_connections_limit
          ACCUM
                t.@entity_list += s
      ;
      
      /* Batching target entities (nested batching) */
  
      FOREACH j IN RANGE[0, num_of_target_batches-1] DO
  
          /* Mapping the potential matches:
          For each relevant low-degree PII (that is connected to the source batched entities),
          check the target batched entities.
          If there is a potential match (a PII in common between entities),
          then save a key-value pair on the relevant entity
          (where the key is the ID of the other similar entity and the value is the initial similarity score of 0).*/
          
          mapped_candidates = SELECT t
              FROM low_degree_piis:s-(@@edge_type_set:e)->Application:t
              WHERE getvid(t)%num_of_target_batches == j
              ACCUM
                t.@is_candidate += TRUE,
                FOREACH v IN s.@entity_list DO
                  IF getvid(v) < getvid(t) OR (v.created_at > compute_entities_after_date AND t.created_at < compute_entities_after_date) THEN
                    t.@entity_map += (v->0.0)
                  END
                END
          ;

          /* Evaluate the potential matches (calculating similarity scores),
          and insert the similarity edges between the similar entities.*/

          evaluated_matches = SELECT t
              FROM piis:s-(@@edge_type_set:e)->Application:t
              WHERE getvid(t)%num_of_target_batches == j AND t.@is_candidate == TRUE
              ACCUM
                CASE e.type
    
                  WHEN "Application_Has_Full_Name" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Full_Name_weight)
                        END
                      END
    
                  WHEN "Application_Has_DOB" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_DOB_weight)
                        END
                      END
    
                  WHEN "Application_Has_Email" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Email_weight)
                        END
                      END
  
                  WHEN "Application_Has_Phone" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Phone_weight)
                        END
                      END
  
                  WHEN "Application_Has_Address" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Address_weight)
                        END
                      END
  
                  WHEN "Application_Has_IP" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_IP_weight)
                        END
                      END
  
                  WHEN "Application_Has_ID" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_ID_weight)
                        END
                      END
  
                  WHEN "Application_Has_Device" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Device_weight)
                        END
                      END
  
                  WHEN "Application_Has_Party" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Party_weight)
                        END
                      END
  
                  WHEN "Application_Has_Account" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Account_weight)
                        END
                      END
  
                  WHEN "Application_Has_Card" THEN
                      FOREACH v IN s.@entity_list DO
                        IF t.@entity_map.containsKey(v) THEN
                          t.@entity_map += (v->Application_Card_weight)
                        END
                      END

                END

              POST-ACCUM

                  FOREACH (k,v) IN t.@entity_map DO
                    FLOAT full_score = 0.0 + v,
                    @@max += full_score, @@min += full_score, @@avg += full_score,
                    IF full_score > (threshold - 0.000001) THEN
                      INSERT INTO Same_Application VALUES (t, k, full_score),
                      @@count += 1
                    END
                  END,

                  t.@entity_map.clear(),
                  t.@is_candidate = FALSE
          ;
  
      END; // End of target batching
  
      cleared_piis = SELECT s
          FROM piis:s
          POST-ACCUM
              s.@entity_list.clear()
      ;
  
  END; // End of source batching
  
  DATETIME end_time = now();
  STRING execution_time = to_string(datetime_diff(end_time, start_time));
  log(true, "UDF:: match_entities end time: " + datetime_format(end_time));
  log(true, "UDF:: match_entities execution time (seconds): " + execution_time);

  PRINT to_string(@@count) AS pairs_matched_count,
      to_string(@@max) AS max_match_score,
      to_string(@@min) AS min_match_score,
      to_string(@@avg) AS avg_match_score
  ;
  
  PRINT execution_time AS execution_time_in_seconds;

}